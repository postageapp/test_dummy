{"name":"Test dummy","tagline":"Simple faker data and model factory for Rails","body":"# test_dummy\r\n\r\nTest Dummy is an easy fake data generator library with the ability to create\r\nindividual fake models or complex, inter-linked sets of models on-demand.\r\n\r\nActiveRecord models, the default for Ruby on Rails, is the only type supported\r\nat this time.\r\n\r\nThe generators produced by Test Dummy can simplify automated testing by making\r\nit possible to have test records created in a known-good state every time\r\ninstead of depending on fixture files which may contain irregularities.\r\n\r\nAfter installing the gem, methods to declare how to fake data are made\r\navailable within ActiveRecord-derived models. There are several ways to\r\ndeclare how to dummy something.\r\n\r\n## Getting Started\r\n\r\n### Add Gem Dependency\r\n\r\nTo add Test Dummy functionality to an application, add the dependency to the\r\n`Gemfile`:\r\n\r\n```ruby\r\ngem 'test_dummy'\r\n```\r\n\r\nMost application frameworks provide some kind of test helper foundation,\r\nlike `test/test_helper.rb` in Rails or `test/helper.rb` in many gem templates.\r\n\r\nInclude the following line in there at an appropriate location:\r\n\r\n```ruby\r\nrequire 'test_dummy'\r\n```\r\n\r\nThis is usually inserted after all the foundational dependencies are taken\r\ncare of, so typically later in the file.\r\n\r\n### Dummy Attributes\r\n\r\nIf a model has no validation requirements, it will already have some basic\r\ndummy functionality. Models can be created simply:\r\n\r\n```ruby\r\ndummy_example = ExampleModel.create_dummy\r\n```\r\n\r\nLike the default `create` method, `create_dummy` also takes arguments that\r\ncan be used to supply pre-defined attributes:\r\n\r\n```ruby\r\nnamed_example = ExampleModel.create_dummy(:name => 'Example')\r\n```\r\n\r\nAny attribute which has validation requirements will need to have a generator\r\nor the models emitted by `create_dummy` cannot be saved. In this example,\r\nif `name` was a required field, this would have to be populated by TestDummy.\r\n\r\nFor convenience, you can add this directly to the model in question:\r\n\r\n```ruby\r\nclass ExampleModel < ActiveRecord::Base\r\n  dummy :name do\r\n    'Test Name'\r\n  end\r\nend\r\n```\r\n\r\nThe `dummy` definition defines an operation that will occur if the attribute\r\nname is not specified. In this case, if `name` is not supplied as an argument\r\nto `create_dummy` then it will be filled in. These operations are attempted in\r\nthe order they are defined.\r\n\r\nKeep in mind it is possible to create invalid model instances if the parameters\r\nsent in would result in a validation error. For instance:\r\n\r\n```ruby\r\nbroken_example = ExampleModel.create_dummy(:name => nil)\r\n\r\nbroken_example.valid?\r\n# => false\r\n```\r\n\r\nThe `dummy` function can be used in several ways to handle a variety of\r\nsituations. The default usage is simple:\r\n\r\n```ruby\r\ndummy :name do\r\n  'Fake Name'\r\nend\r\n```\r\n\r\nIn this case, whatever is returned by the block is inserted into the listed\r\nattribute if that attribute was not speficied in the options.\r\n\r\nIt is possible to dummy several attributes at the same time:\r\n\r\n```ruby\r\ndummy :password, :password_confirmation do\r\n  'testpassword'\r\nend\r\n```\r\nThis will be applied to any of the listed attributes that have not been\r\nspecified in the options.\r\n\r\nIf access to the model that's being constructed is required, it is passed in\r\nas the first argument to the block:\r\n\r\n```ruby\r\ndummy :description do |example|\r\n  \"Example with a name of length %d\" % example.name.length\r\nend\r\n```\r\nThe model itself can be manipulated in any way that's required, such as setting\r\nother fields, calling methods, and so forth, but it's important to be careful\r\nhere as the model at this point is incomplete if there are other attributes\r\nwhich have yet to have had their `dummy` generator called.\r\n\r\n### Separate Definition File\r\n\r\nIf including the attribute dummy generators in the main model file produces\r\ntoo much clutter, they can be relocated to an alternate location. This has the\r\nadvantage in that they will only be loaded if a dummy operation is performed,\r\nso a production application will not be affected by their presence.\r\n\r\nAn example model `app/models/example_model.rb` file looks like:\r\n\r\n```ruby\r\nclass ExampleModel < ActiveRecord::Base\r\n  dummy :name do\r\n    \"Random Name \\#%d\" % rand(10e6)\r\n  end\r\n  \r\n  dummy :password, :password_confirmation do\r\n    'tester'\r\n  end\r\n  \r\n  dummy :nickname, :use => :random_phonetic_string\r\nend\r\n```\r\n\r\nTo avoid cluttering up your models with lots of dummy-related code, this can\r\nbe stored in the `test/dummy` directory as a secondary file that's loaded as\r\nrequired.\r\n\r\nAn example `test/dummy/example_model.rb` looks like this:\r\n\r\n```ruby\r\nclass ExampleModel\r\n  dummy :name do\r\n    \"Random Name \\#%d\" % rand(10e6)\r\n  end\r\n\r\n  dummy :password, :password_confirmation do\r\n    'tester'\r\n  end\r\n\r\n  dummy :nickname, :use => :random_phonetic_string\r\nend\r\n```\r\n\r\nNote that, like any patch to an existing class, it is not strictly required to\r\nre-declare the parent class.\r\n\r\nThe name of the test/dummy file should be the same as the main model\r\ndefined in app/models. For instance, app/models/my_model.rb would have a\r\ncorresponding test/dummy/my_model.rb which is loaded on demand.\r\n\r\n## Development and Testing\r\n\r\nFor simplicity and portability, SQLite3 is used as the database back-end for\r\ntesting. If any changes are made to existing migrations the temporary database\r\nwill need to be deleted before they're applied.\r\n\r\n## Copyright\r\n\r\nCopyright (c) 2010-2013 Scott Tadman, The Working Group Inc.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}